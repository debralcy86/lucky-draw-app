import crypto from 'node:crypto';
import { Buffer } from 'node:buffer';
export const config = { runtime: 'nodejs' };

import { createClient } from '@supabase/supabase-js';
import verifyInitData, { verifyTelegramInitData } from './_lib/telegramVerify.mjs';
import { withCors } from './_lib/cors.mjs';
function ok(res, data) { return res.status(200).json({ ok: true, ...data }); }
function bad(res, error) { return res.status(400).json({ ok: false, reason: error }); }
function err(res, error) { return res.status(500).json({ ok: false, reason: error }); }

function parseTMA(req, botToken) {
  const h = req.headers.authorization || req.headers.Authorization || '';
  if (!h || !h.toString().startsWith('tma ')) return { ok: false };
  const initData = h.toString().slice(4).trim();
  const check = verifyTelegramInitData(initData, botToken) || verifyInitData(initData, botToken);
  if (!check?.ok) return { ok: false };
  const userId = String(check.userId || check.user?.id || check.user?.user?.id || '');
  if (!userId) return { ok: false };
  return { ok: true, userId };
}


function isAdminViaTMA(req, botToken, adminIdsCsv) {
  if (!botToken || !adminIdsCsv) return false;
  const parsed = parseTMA(req, botToken);
  if (!parsed.ok) return false;
  const allow = new Set(String(adminIdsCsv).split(',').map(s => s.trim()).filter(Boolean));
  return allow.has(parsed.userId);
}

async function readJSON(req) {
  if (typeof req?.json === 'function') {
    try { return await req.json(); } catch {}
  }
  try {
    const chunks = [];
    for await (const c of req) chunks.push(c);
    const raw = Buffer.concat(chunks).toString('utf8');
    return raw ? JSON.parse(raw) : {};
  } catch {
    return null;
  }
}

async function handler(req, res) {
  if (req.method !== 'POST') return res.status(405).json({ ok: false, reason: 'Method Not Allowed' });

  const { SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, TELEGRAM_BOT_TOKEN, ADMIN_USER_IDS } = process.env;
  if (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return err(res, 'server_misconfig');

  const authed = isAdminViaTMA(req, TELEGRAM_BOT_TOKEN, ADMIN_USER_IDS);
  if (!authed) return res.status(401).json({ ok: false, reason: 'unauthorized' });

  const body = await readJSON(req);
  if (!body || typeof body !== 'object') return bad(res, 'invalid_json');
  const action = String(body.action || '').trim();

  const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, { auth: { persistSession: false } });

  if (action === 'ping') {
    return ok(res, { pong: true });
  }

  if (action === 'metrics') {
    const r1 = await supabase.from('profiles').select('user_id', { count: 'exact', head: true });
    const r2 = await supabase.from('wallets').select('user_id,balance');
    const r3 = await supabase.from('wallet_txns').select('id', { count: 'exact', head: true });
    if (r1.error) return err(res, 'profiles_count_failed');
    if (r2.error) return err(res, 'wallets_select_failed');
    if (r3.error) return err(res, 'txns_count_failed');
    const totalBalance = (r2.data || []).reduce((s, w) => s + (Number(w.balance) || 0), 0);
    return ok(res, {
      metrics: {
        profiles: r1.count || 0,
        wallets: (r2.data || []).length,
        total_balance: totalBalance,
        txns: r3.count || 0
      }
    });
  }

  if (action === 'credit') {
    const userId = String(body.userId || '').trim();
    const delta = Number(body.delta);
    const note = (body.note == null ? '' : String(body.note)).slice(0, 200);
    if (!userId) return bad(res, 'missing_user');
    if (!Number.isFinite(delta) || delta === 0) return bad(res, 'invalid_delta');

    const txType = delta >= 0 ? 'credit' : 'debit';

    const wUp = await supabase
      .from('wallets')
      .upsert({ user_id: userId, balance: 0 }, { onConflict: 'user_id' })
      .select('user_id,balance')
      .eq('user_id', userId)
      .maybeSingle();
    if (wUp.error) return err(res, 'wallet_upsert_failed');

    const wUpd = await supabase.rpc('wallet_increment_balance', { p_user_id: userId, p_delta: delta }).then(r => {
      if (r.error && r.error.code === 'PGRST204') return null;
      return r;
    });

    if (!wUpd || wUpd.error) {
      const wSel = await supabase.from('wallets').select('balance').eq('user_id', userId).maybeSingle();
      const newBal = (Number(wSel.data?.balance) || 0) + delta;
      const wSet = await supabase.from('wallets').update({ balance: newBal }).eq('user_id', userId);
      if (wSet.error) return err(res, 'wallet_update_failed');
    }

    const wNow = await supabase.from('wallets').select('user_id,balance').eq('user_id', userId).maybeSingle();
    if (wNow.error) return err(res, 'wallet_fetch_failed');

    const txn = await supabase.from('wallet_txns').insert([{
      user_id: userId,
      type: txType,
      amount: delta,
      balance_after: Number(wNow.data?.balance) || 0,
      note: note || null
    }]).select('id').maybeSingle();
    if (txn.error) { console.error('admin.credit txn error', txn.error); return err(res, 'txn_insert_failed'); }

    return ok(res, { user_id: userId, balance: Number(wNow.data?.balance) || 0, applied: delta });
  }

    if (action === 'approve_deposit') {
    const { requestId } = body;
    if (!requestId) return bad(res, 'missing_request_id');

    const dep = await supabase.from('deposit_requests')
      .update({ status: 'approved' })
      .eq('id', requestId)
      .select('*')
      .maybeSingle();
    if (dep.error || !dep.data) return err(res, 'deposit_update_failed');

    const { user_id, amount, ref } = dep.data;

    // increment wallet
    const wUpd = await supabase.rpc('wallet_increment_balance', { p_user_id: user_id, p_delta: amount });
    if (wUpd.error) return err(res, 'wallet_increment_failed');

    const wNow = await supabase.from('wallets').select('balance').eq('user_id', user_id).maybeSingle();
    if (wNow.error) return err(res, 'wallet_fetch_failed');

    await supabase.from('wallet_txns').insert([{
      user_id,
      type: 'deposit',
      amount,
      balance_after: Number(wNow.data?.balance) || 0,
      note: ref || 'deposit approved'
    }]);

    return ok(res, { approved: true, user_id, amount });
  }

  if (action === 'approve_withdraw') {
    if (body.amount !== undefined) {
      const amt = Number(body.amount);
      if (!Number.isFinite(amt) || amt < 10) {
        return bad(res, 'min_withdraw_10');
      }
    }
    const { requestId, approve } = body; // approve=true or false
    if (!requestId) return bad(res, 'missing_request_id');

    const status = approve ? 'approved' : 'rejected';
    const wd = await supabase.from('withdraw_requests')
      .update({ status })
      .eq('id', requestId)
      .select('*')
      .maybeSingle();
    if (wd.error || !wd.data) return err(res, 'withdraw_update_failed');

    const { user_id, amount, destination } = wd.data;

    if (approve) {
      const wUpd = await supabase.rpc('wallet_increment_balance', { p_user_id: user_id, p_delta: -amount });
      if (wUpd.error) return err(res, 'wallet_decrement_failed');

      const wNow = await supabase.from('wallets').select('balance').eq('user_id', user_id).maybeSingle();
      if (wNow.error) return err(res, 'wallet_fetch_failed');

      await supabase.from('wallet_txns').insert([{
        user_id,
        type: 'withdraw',
        amount: -amount,
        balance_after: Number(wNow.data?.balance) || 0,
        note: destination || 'withdraw approved'
      }]);
    }

    return ok(res, { user_id, amount, status });
  }

// List withdraw requests (paginated, optional status filter)
if (action === 'list_withdraws') {
  const statusFilter = (body.status == null) ? null : String(body.status);
  const limit = Math.min(Number(body.limit) || 50, 500);
  const offset = Math.max(Number(body.offset) || 0, 0);

  let q = supabase.from('withdraw_requests').select('*');
  if (statusFilter) q = q.eq('status', statusFilter);
  q = q.order('created_at', { ascending: false }).range(offset, offset + limit - 1);

  const r = await q;
  if (r.error) return err(res, 'withdraws_list_failed');
  return ok(res, { withdraws: r.data || [] });
}

// List deposit requests (paginated, optional status filter)
if (action === 'list_deposits') {
  const statusFilter = (body.status == null) ? null : String(body.status);
  const limit = Math.min(Number(body.limit) || 50, 500);
  const offset = Math.max(Number(body.offset) || 0, 0);

  let q = supabase.from('deposit_requests').select('*');
  if (statusFilter) q = q.eq('status', statusFilter);
  q = q.order('created_at', { ascending: false }).range(offset, offset + limit - 1);

  const r = await q;
  if (r.error) return err(res, 'deposits_list_failed');
  return ok(res, { deposits: r.data || [] });
}

// Transactions paging for admin list view
if (action === 'txns') {
  const limit = Math.min(Number(body.limit) || 50, 500);
  const offset = Math.max(Number(body.offset) || 0, 0);
  const r = await supabase.from('wallet_txns')
    .select('*')
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);
  if (r.error) return err(res, 'txns_list_failed');
  return ok(res, { txns: r.data || [] });
}

// Users management - list all profiles
if (action === 'users') {
  const limit = Math.min(Number(body.limit) || 50, 500);
  const offset = Math.max(Number(body.offset) || 0, 0);

  const q = await supabase
    .from('profiles')
    .select('user_id,name,contact,is_admin,withdraw_method,withdraw_dest,withdraw_holder,created_at,updated_at')
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (q.error) {
    console.error('admin.users error', q.error);
    return err(res, 'users_fetch_failed');
  }
  return ok(res, { users: q.data || [] });
}

// Update a user (admin sets flags or updates withdraw setup)
if (action === 'user_update') {
  const userId = String(body.user_id || '').trim();
  if (!userId) return bad(res, 'missing_user_id');

  const updates = {};
  if (body.is_admin !== undefined) updates.is_admin = !!body.is_admin;
  if (body.withdraw_method !== undefined) updates.withdraw_method = String(body.withdraw_method);
  if (body.withdraw_dest !== undefined) updates.withdraw_dest = String(body.withdraw_dest);
  if (body.withdraw_holder !== undefined) updates.withdraw_holder = String(body.withdraw_holder);
  if (body.name !== undefined) updates.name = String(body.name);
  if (body.contact !== undefined) updates.contact = String(body.contact);
  updates.updated_at = new Date().toISOString();

  const u = await supabase
    .from('profiles')
    .update(updates)
    .eq('user_id', userId)
    .select()
    .maybeSingle();

  if (u.error) {
    console.error('admin.user_update error', u.error);
    return err(res, 'user_update_failed');
  }

  return ok(res, { user: u.data });
}

// Points In/Out (Points Tracking)
if (action === 'points') {
  const limit = Math.min(Number(body.limit) || 50, 500);
  const offset = Math.max(Number(body.offset) || 0, 0);

  const q = await supabase
    .from('wallet_txns')
    .select('id,user_id,type,amount,balance_after,note,created_at')
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (q.error) {
    console.error('admin.points error', q.error);
    return err(res, 'points_fetch_failed');
  }
  return ok(res, { txns: q.data || [] });
}

// Figures Data (Live BET data)
if (action === 'bets_live') {
  const drawSel = await supabase.from('draws').select('id').eq('status','open').maybeSingle();
  if (drawSel.error || !drawSel.data) return err(res,'draw_open_fetch_failed');
  const drawId = drawSel.data.id;
  const bets = await supabase.from('bets')
    .select('group_code,figure,amount')
    .eq('draw_id', drawId);
  if (bets.error) return err(res,'bets_fetch_failed');
  const totals = {};
  for (const b of bets.data || []) {
    if (!totals[b.group_code]) totals[b.group_code] = {};
    totals[b.group_code][b.figure] = (totals[b.group_code][b.figure]||0) + Number(b.amount||0);
  }
  return ok(res, { draw_id: drawId, totals });
}

// Result Posting (Draw Result Posting)
if (action === 'draw_post') {
  const { draw_id, winning_figure } = body;
  if (!draw_id || !winning_figure) return bad(res,'missing_draw_or_figure');
  const upd = await supabase.from('draws')
    .update({ winning_figure, status:'closed', updated_at: new Date().toISOString() })
    .eq('id', draw_id)
    .select('*')
    .maybeSingle();
  if (upd.error || !upd.data) return err(res,'draw_update_failed');
  return ok(res, { draw: upd.data });
}

// Admin Reports (Master Supabase Table Screen)
if (action === 'reports') {
  const table = String(body.table || '').trim();
  if (!table) return bad(res,'missing_table');
  const limit = Math.min(Number(body.limit)||50,500);
  const offset = Math.max(Number(body.offset)||0,0);
  let q = supabase.from(table).select('*');
  if (body.status) q = q.eq('status', String(body.status));
  q = q.order('created_at',{ascending:false}).range(offset, offset+limit-1);
  const r = await q;
  if (r.error) {
    console.error('admin.reports error', r.error);
    return err(res,'reports_fetch_failed');
  }
  return ok(res,{ table, rows:r.data||[] });
}

// List all figures for current draw (alternative to bets_live)
if (action === 'list_figures') {
  const drawSel = await supabase.from('draws').select('id').eq('status','open').maybeSingle();
  if (drawSel.error || !drawSel.data) return err(res,'draw_open_fetch_failed');
  const drawId = drawSel.data.id;
  const r = await supabase.from('bets')
    .select('user_id,group_code,figure,amount,created_at')
    .eq('draw_id', drawId)
    .order('created_at',{ascending:false});
  if (r.error) return err(res,'figures_list_failed');
  return ok(res,{ draw_id: drawId, bets:r.data||[] });
}

// Explicit result posting (alternative to draw_post)
if (action === 'post_results') {
  const { draw_id, figure } = body;
  if (!draw_id || !figure) return bad(res,'missing_draw_or_figure');
  const upd = await supabase.from('draws')
    .update({ winning_figure: figure, status:'closed', updated_at:new Date().toISOString() })
    .eq('id', draw_id)
    .select('*')
    .maybeSingle();
  if (upd.error || !upd.data) return err(res,'result_post_failed');
  return ok(res,{ draw: upd.data });
}

// Admin-triggered PIN reset
if (action === 'user_reset_pin') {
  const userId = String(body.user_id || '').trim();
  if (!userId) return bad(res,'missing_user_id');
  const newPin = String(Math.floor(1000 + Math.random() * 9000)); // 4-digit PIN
  const hash = crypto.createHash('sha256').update(newPin).digest('hex');
  const u = await supabase
    .from('profiles')
    .update({ pin_hash: hash, updated_at: new Date().toISOString() })
    .eq('user_id', userId)
    .select('user_id')
    .maybeSingle();
  if (u.error || !u.data) {
    console.error('admin.user_reset_pin error', u.error);
    return err(res,'user_reset_pin_failed');
  }
  return ok(res,{ user_id: userId, reset: true, new_pin: newPin });
}

console.log('TAG: admin.mjs list/report actions added');
return bad(res, 'unknown_action');
}

export default withCors(handler, { methods: ['POST', 'OPTIONS'], exposeHeaders: ['Content-Type'] });
