// api/wallet.mjs
import { withCors } from './_lib/cors.mjs';
import { getSupabaseAdmin } from './_lib/supabaseClient.mjs';

/** Consistent JSON responses */
function json(res, status, body) {
  res.statusCode = status;
  res.setHeader('Content-Type', 'application/json; charset=utf-8');
  res.end(JSON.stringify(body));
}

/** Read JSON body for runtimes that don't auto-parse */
async function readJson(req) {
  if (req.body && typeof req.body === 'object') return req.body;
  const chunks = [];
  for await (const c of req) chunks.push(c);
  const raw = Buffer.concat(chunks).toString('utf-8').trim();
  return raw ? JSON.parse(raw) : {};
}

async function handler(req, res) {
  try {
    const supabase = getSupabaseAdmin();

    // ---------- GET /api/wallet?userId=... ----------
    if (req.method === 'GET') {
      const userId = (req.query?.userId ?? '').toString().trim();
      if (!userId) return json(res, 400, { ok: false, error: 'Missing required query param: userId' });

      // wallet
      const { data: walletRows, error: walletErr } = await supabase
        .from('wallets')
        .select('*')
        .eq('user_id', userId)
        .limit(1);

      if (walletErr) return json(res, 500, { ok: false, error: 'Failed to fetch wallet', details: walletErr.message });
      const wallet = walletRows?.[0] ?? null;

      // latest 50 transactions
      const { data: txns, error: txErr } = await supabase
        .from('wallet_txns')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .limit(50);

      if (txErr) return json(res, 500, { ok: false, error: 'Failed to fetch transactions', details: txErr.message });

      return json(res, 200, { ok: true, wallet, txns });
    }

    // ---------- POST /api/wallet (admin only) ----------
    if (req.method === 'POST') {
      // temporary admin guard
      const headerToken = req.headers['x-admin-token'];
      if (!headerToken || headerToken !== process.env.ADMIN_TOKEN) {
        return json(res, 401, { ok: false, error: 'Unauthorized (invalid x-admin-token)' });
      }

      const body = await readJson(req);
      const userId = (body.userId ?? '').toString().trim();
      const deltaRaw = body.delta;
      const note = (body.note ?? '').toString().trim();

      if (!userId) return json(res, 400, { ok: false, error: 'Missing body.userId' });
      if (deltaRaw === undefined || deltaRaw === null || Number.isNaN(Number(deltaRaw))) {
        return json(res, 400, { ok: false, error: 'Missing or invalid body.delta (number)' });
      }

      const delta = Number(deltaRaw);

      // current balance
      const { data: exists, error: fetchErr } = await supabase
        .from('wallets')
        .select('balance')
        .eq('user_id', userId)
        .limit(1);

      if (fetchErr) return json(res, 500, { ok: false, error: 'Failed to fetch current wallet', details: fetchErr.message });

      const current = exists?.[0]?.balance ?? 0;
      const newBalance = Number(current) + delta;

      // upsert wallet
      const { error: upsertErr } = await supabase
        .from('wallets')
        .upsert([{ user_id: userId, balance: newBalance }], { onConflict: 'user_id' });

      if (upsertErr) return json(res, 500, { ok: false, error: 'Failed to upsert wallet', details: upsertErr.message });

      // insert transaction
      const type = delta > 0 ? 'credit' : 'debit';
      const { error: txnErr } = await supabase
        .from('wallet_txns')
        .insert([{
          user_id: userId,
          type,
          amount: delta,
          balance_after: newBalance,
          note: note || null,
        }]);

      if (txnErr) {
        return json(res, 500, {
          ok: false,
          error: 'Balance updated but failed to log transaction',
          details: txnErr.message,
          balance: newBalance
        });
      }

      return json(res, 200, { ok: true, balance: newBalance });
    }

    res.setHeader('Allow', 'GET, POST');
    return json(res, 405, { ok: false, error: 'Method Not Allowed' });
  } catch (err) {
    console.error('[api/wallet] Handler error:', err);
    return json(res, 500, { ok: false, error: 'Unexpected error', details: err?.message || String(err) });
  }
}

// Wrap with a safety net to log any unexpected errors
export default withCors(async function wrappedHandler(req, res) {
  try {
    return await handler(req, res);
  } catch (err) {
    console.error('[api/wallet] Unexpected error:', err);
    if (!res.headersSent) {
      try {
        return json(res, 500, { ok: false, error: 'Unexpected error', details: err?.message || String(err) });
      } catch (_) {
        // As a last resort, end the response
        try { res.statusCode = 500; res.end('Unexpected error'); } catch (_) {}
      }
    }
  }
});
